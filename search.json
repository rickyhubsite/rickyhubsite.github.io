[{"title":"最便宜稳定的香港奈飞解锁？NiiHost HK V6 评测","path":"/06319e9a45ac/","content":"简介618时入手了 NiiHost 的香港 IPV6-ULTRA-KVM，原价年付9.99刀打五折后只要5刀一年，且官方声称解锁流媒体。因为感觉基于容器的 LXC 隔离度不够，还是选择了稍微贵一点的 KVM。机器本身是 1核512MB 内存的，1T 流量 + 1Gbps 的带宽，所以基本上只能用来当代理节点用，跑不了什么复杂的任务。 IP 质量ipv6使用 IP Quality 脚本测试结果： 香港原生 IP，奈飞和 ChatGPT 这些都可以正常解锁。虽然都显示机房 IP，但对我来说够用了，本来主要也只是用来看奈飞的（主要是有些资源在美区奈飞没有）。 ipv4由于机器只自带 ipv6 的出入站，需要添加 ipv4 出站需要使用 Cloudflare Warp，主要用于一些不支持 ipv6 的网站，比如 GitHub。但是 Warp 的 IP,懂的都懂，奈飞解锁和风险度比较看脸而且不稳定。不过好在奈飞支持 ipv6 访问，我直接给机器设置了 ipv6 优先。 延迟电信和联通绕美，直连一般都是200+。不过移动和教育网都是直连，延迟可以到60多毫秒。 速度实际使用下来，用来看奈飞完全没有问题。跑官方的fast.com测速可以有50Mbps，算是够用了。不过不知道是性能限制还是其他的什么原因，网速要跑到峰值有时会比较慢，所以一集刚开始的时候画质比较差，过一会速率起来就正常了。不过还是那句话，能用就行。毕竟5刀一年还要什么自行车。","tags":["VPS","Linux"],"categories":["技术"]},{"title":"Easytier 轻松实现异地组网","path":"/e7cb6b6b7673/","content":"什么是异地组网？异地组网，也称为远程组网或Site-to-Site VPN，是一种通过公共网络将两个或多个地理位置不同的局域网（LAN）连接起来，形成一个统一的虚拟局域网（VLAN）的技术。简单来说，它能让身处不同地方的设备，如同在同一个局域网内一样互相访问和通信。无论是在家、在办公室，还是在全球任何一个角落，只要设备连接到这个虚拟网络，就能安全、便捷地共享资源。 为何需要异地组网？ 高效地实现内网穿透：对于个人使用而言，使用异地组网实现内网穿透不同于 frp 等端口转发的方式，单次部署就能穿透所有端口，实现一劳永逸。 多设备互联：异地组网的一大要点就是其具有组网的优势，特别是当机器数量比较多时，可以轻松实现多设备互联，这也是 frp 做不到的一点。 隐私性与安全性：不同于 frp，异地组网需要本地安装有客户端，且同样可以设置身份认证与加密传输，相比反向代理到公网在隐私性和安全性上表现更好。 Easytier 有什么优势？在众多异地组网工具中，Zerotier 和 Tailscale 是大家熟悉的选择。然而新兴的开源工具 Easytier 凭借其独特的优势，正成为一个可行的替代方案，目前在 GitHub 上已经有 5.8k 个 star。下面介绍一下 Easytier 相比 Zerotier 和 Tailscale 的主要优势： 完全开源且社区驱动：完全开源免费，无付费版本，目前 GitHub 上更新活跃。 去中心化：节点平等且独立，无需中心化服务。即使某个节点挂掉，只要网络中其它节点间存在可达路径，整个虚拟网络仍然能够正常通讯。 支持 TCP 连接：其它使用 UDP 连接的工具都具有一个相同的缺点，即容易被运营商 QoS（简单理解就是对 UDP 限速）。Easytier 可以手动指定使用的连接协议，从而避免这个问题。 支持 P2P：打洞成功后，可以不经过中间节点中转，实现点对点直连。当然这个功能 Zerotier 和 Tailscale 也支持。 易于使用：支持通过网页、客户端和命令行多种操作方式，但本文将使用命令行 + 配置文件实现简易部署。 高性能：使用 Rust 编写，具有高性能且内存安全的特点。 Easytier 部署教程搭建自己私有的 Easytier 服务，需要拥有一台具有公网 IP 的服务器。或者也可以使用 Easytier 提供的公共共享节点，但在下面的配置中我会关闭这个功能。 安装 Easytier建议从 GitHub Release 上下载预编译好的二进制文件或者自己编译： mkdir -p ~/.easytiercd ~/.easytierwget https://github.com/EasyTier/EasyTier/releases/download/v2.3.2/easytier-linux-x86_64-v2.3.2.zip 解压并只保留命令行版本： unzip easytier-linux-x86_64-v2.3.2.zipmv easytier-linux-x86_64/easytier-cli easytier-linux-x86_64/easytier-core .rm -rf easytier-linux-x86_64 easytier-linux-x86_64-v2.3.2.zip 生成配置文件使用官网提供的配置文件生成工具生成网络 ID，也就是instance_id。 然后，在第一台机器（具有公网 IP 的）中使用下面的配置文件 config.toml，其中虚拟内网的网段可以自选（这里使用的是 192.168.88.0/24）： instance_name = 网络名instance_id = 网络 IDipv4 = 192.168.88.1/24dhcp = falselisteners = [tcp://0.0.0.0:11010] rpc_portal = 0.0.0.0:0[network_identity]network_name = 连接账号network_secret = 连接密码[flags]dev_name = easytierlatency_first = trueprivate_mode = true 第二台机器的配置文件如下所示： instance_name = 网络名instance_id = 网络 IDipv4 = 192.168.88.2/24dhcp = falselisteners = [tcp://0.0.0.0:11010]rpc_portal = 0.0.0.0:0[network_identity]network_name = 连接账号network_secret = 连接密码[[peer]]uri = tcp://第一台机器的公网IP:11010[flags]dev_name = easytierlatency_first = trueprivate_mode = true 如果有多台机器，配置文件都基本相同。例如加入第三台机器，把另外两台机器作为 peer： instance_name = 网络名instance_id = 网络 IDipv4 = 192.168.88.3/24dhcp = falselisteners = [tcp://0.0.0.0:11010]rpc_portal = 0.0.0.0:0[network_identity]network_name = 连接账号network_secret = 连接密码[[peer]]uri = tcp://第一台机器的公网IP:11010[[peer]]uri = tcp://第二台机器的公网IP:11010[flags]dev_name = easytierlatency_first = trueprivate_mode = true 设置子网代理如果想在虚拟内网中访问某一个节点的内网，则需要设置子网代理。这个功能对于 NAS 用户可能需要用到。例如，我们想要接入节点 A 的内网 192.168.2.024，这只需要在节点 A 的配置文件中加入下面的部分即可： [[proxy_network]]cidr = 192.168.2.0/24 设置为 systemd 服务sudo cat /etc/systemd/system/easytier.service EOF[Unit]Description=EasyTier ServiceAfter=network.target syslog.targetWants=network.target[Service]Type=simpleExecStart=/home/系统用户名/.easytier/easytier-core -c /home/系统用户名/.easytier/config.tomlRestart=on-failureRestartSec=5[Install]WantedBy=multi-user.targetEOFsudo systemctl enable easytiersudo systemctl start easytier","tags":["网络","VPS","组网","NAS"],"categories":["技术"]},{"title":"如何显示站点总浏览量与访问数？","path":"/fdc514f7fc0a/","content":"Cloudflare Worker 转发 API:addEventListener(fetch, event = event.respondWith(handleRequest(event.request)))async function handleRequest(request) // 获取环境变量 const UMAMI_API_URL = https://你的umami地址/api; const UMAMI_WEBSITE_ID = 网站id; const UMAMI_API_TOKEN = umami token; // 获取请求 URL const url = new URL(request.url); const startAt = url.searchParams.get(startAt) || 2024-01-01T00:00:00Z; // 获取开始时间，默认为 2024-01-01 const endAt = url.searchParams.get(endAt) || new Date().toISOString(); // 获取结束时间，默认为当前时间 // 构建 Umami API 请求 URL const apiUrl = `$UMAMI_API_URL/websites/$UMAMI_WEBSITE_ID/stats?startAt=$new Date(startAt).getTime()endAt=$new Date(endAt).getTime()stats`; try // 发送请求到 Umami API const response = await fetch(apiUrl, headers: Authorization: `Bearer $UMAMI_API_TOKEN`, Content-Type: application/json, , ); if (!response.ok) console.error(`Umami API error: $response.status - $response.statusText`); return new Response(JSON.stringify( error: `Umami API error: $response.status` ), status: response.status, headers: Content-Type: application/json , ); // 解析 Umami API 响应 const data = await response.json(); // 提取所需的数据（例如，页面浏览量） const pageviews = data.pageviews.value; const visits = data.visits.value; // 构建响应数据 const responseData = pageviews: pageviews, visits: visits, timestamp: new Date().toISOString(), ; // 返回响应 return new Response(JSON.stringify(responseData), headers: Content-Type: application/json, Access-Control-Allow-Origin: *, // 允许跨域请求，根据需要修改 , ); catch (error) console.error(Error fetching or processing data:, error); return new Response(JSON.stringify( error: error.message ), status: 500, headers: Content-Type: application/json , ); 部署完之后，访问 Cloudflare Worker 的地址，应该可以看到类似的结果： pageviews:xxx,visits:xxx,timestamp:xxxx-xx-xxxxx:xx:xx.xxxZ 本站使用的 js 脚本：document.addEventListener(DOMContentLoaded, function() const startAt = new Date(2025-07-16T00:12:55.346Z).getTime(); // 改为你的开始时间 fetch(`Cloudflare Worker 地址`, ) .then(response = response.json()) .then(data = const viewsElement = document.getElementById(pageviews-count); viewsElement.textContent = `$data.pageviews`; const visitsElement = document.getElementById(visits-count); visitsElement.textContent = `$data.visits`; const endAt = new Date(data.timestamp).getTime(); const timeDiff = endAt - startAt; const daysRunning = Math.floor(timeDiff / (1000 * 3600 * 24)); const daysElement = document.getElementById(days-count); daysElement.textContent = `$daysRunning`; );); 之后只要在网站的 head 中插入下面的代码就行了： script defer src=js脚本地址/script 在页面底部显示footer 代码： 本站已运行: span id=days-count.../span 天, 总浏览量: span id=pageviews-count.../span, 总访问数: span id=visits-count.../span","tags":["网络","博客"],"categories":["技术"]},{"title":"【低成本搭建】魔法从0到毕业","path":"/44fcc85409a8/","content":"前提知识 (某种规则怪谈) 大部分情况下，墙是单向的 大部分情况下，墙是黑名单制 墙是分布式的，且存在地域差异 墙是黑盒，且在不断更新 前提准备要搭建自己的前向代理服务，需要做好以下的准备： 至少一台海外 VPS (Virtual Private Server)，即虚拟专用服务器，一般装 Linux 系统 合适的代理协议，保证不被封 服务端软件，用于在 VPS 上部署代理服务 客户端软件，用于连接服务端实现代理，安装在需要代理的机器上 下面将对这几个方面进行一一介绍。 1️⃣ 海外 VPS 选择VPS 的质量参差不齐，价格差异也非常大。选择什么样的 VPS 取决于你的具体需求。一般来说，VPS需要关注以下几点参数： 带宽：决定了连接速度的上限，但国内直连的速度还和线路相关。例如一台带宽为 1G 的海外 VPS，从海外网站下载的速度可能有 (10008) 125 MBs，但用它为代理的速度可能只有10 MBs。 线路：主要分为非优化和优化，决定了连接的延迟、稳定性以及速度。三家运营商 (移动、电信、联通)分别有自家的普通网络 (分别为163、CMI、4837) 和优化网络。优化网络又有不同级别。 IP 质量：和流媒体解锁相关，如看奈飞就对 IP 的要求较高，而看油管就基本无所谓。另外，如果 IP 的风险度较高，在访问网页时可能经常要人机验证。 CPU 以及内存：1核心 + 1GB 内存 (即1c1g) 即可，512MB 内存勉强也行。 磁盘空间：对于搭建节点来说一般不影响，甚至 5GB 都可以。 关于具体的 VPS 挑选，推荐看 DigVPS 这个网站。上面列举了不同 VPS 服务商的不同地区的 VPS，包含了上面提到的各种参数以及对 VPS 的主观评分。 一般而言，如果只是简单的浏览网页，一台 100 一年的 Zgo Global VPS (没收广告费) 就足够了。同时它的 IP 质量也不错，原生 IP + 流媒体全解锁，看奈飞、用各种 AI 工具无压力。 对于日本 VPS，可以考虑云悠（YUNYOO）200 一年的 TCVM Tokyo (原生 IP，流媒体全解锁) 或者 Akile 100 一年的 JPIIJ (非原生 IP，流媒体全解锁)。 香港 VPS 的优点是延迟比较低 (前提是直连不绕路由)，但缺点是一般比较贵。魔法入门一般推荐用美西的 VPS。 购买了 VPS 后，可以直接在命令行 (windows 用 cmd 即可) 使用 ssh 登陆。 ssh 系统用户名@公网IP -p 端口号 2️⃣ 代理协议选择正所谓“道高一尺，魔高一丈”，墙和协议都是在不停进化的，所以只推荐使用最新的代理 (下面列举的前两个)。下面列举几种热门的协议： ✅ vision 流控 + reality ✅ anyTLS ❌ vmess + ws + tls (存在 TIT 特征，部分地区容易被封) ❌ trojan + tls (存在 TIT 特征，容易被封) ❌ shadowsocks (过时，秒封 IP) … 3️⃣ 服务端选择推荐使用 Xray 和 mihomo (原名 Clash.Meta)，其中 vision 流控 + reality 可以在 Xray 上部署，anyTLS 可以在 mihomo 上部署。 Xray 部署推荐使用 x-ui 面板部署。用 root 用户执行以下下载命令： bash (curl -Ls https://raw.githubusercontent.com/FranzKafkaYu/x-ui/956bf85bbac978d56c0e319c5fac2d6db7df9564/install.sh) 0.3.4.4 由于使用 x-ui 需要域名并配置证书实现 https 访问，否则会有消息泄漏风险，较为麻烦，本文不再赘述。感兴趣可以油管搜“不良林”。如果想要更简单的部署方式，推荐使用下面的 mihomo 部署 anyTLS 节点。 mihomo 部署首先从 Github Release 下载最新的二进制文件，放到目标文件夹中： mkdir -p ~/.mihomocd ~/.mihomowget https://github.com/MetaCubeX/mihomo/releases/download/v1.19.11/mihomo-linux-amd64-compatible-v1.19.11.gz 解压并重命名，赋予可执行权限： gzip -d mihomo-linux-amd64-compatible-v1.19.11.gzmv mihomo-linux-amd64-compatible-v1.19.11 mihomochmod +x mihomo 生成自签名证书： openssl req -x509 -newkey ec:(openssl ecparam -name prime256v1) -keyout ./server.key -out ./server.crt -days 36500 -nodes -subj /CN=bing.com 写入配置文件： cat config.yaml EOFlisteners:- name: 节点名任取 type: anytls port: 8443 listen: 0.0.0.0 users: 用户名: 密码 certificate: ./server.crt private-key: ./server.key padding-scheme: | stop=6 0=30-30 1=100-400 2=400-500,c,500-1000,c,500-1000,c,500-1000,c,500-1000 3=9-9,500-1000 4=500-1000 5=500-1000 6=500-1000 7=500-1000EOF 设置为 systemd 服务实现自动启动： sudo cat /etc/systemd/system/mihomo.service EOF[Unit]Description = mihomoAfter = network.target syslog.targetWants = network.target[Service]Type = simpleExecStart = /home/系统用户名/.mihomo/mihomo -d /home/系统用户名/.mihomo/Restart = on-failureRestartSec = 5[Install]WantedBy = multi-user.targetEOFsudo systemctl enable mihomosudo systemctl start mihomo 4️⃣ 客户端选择除了 iOS 端，推荐使用 FlClash；iOS 端推荐使用 Shadowrocket (需要非国区 id)。另外对 Windows 端或 Mac 端，还可以使用 V2rayN，但我更偏向于使用 Clash 系 (FlClash 默认使用 mihomo 内核)。 之后导入节点只需要手动编辑配置文件即可。","tags":["网络","VPS","魔法"],"categories":["技术"]},{"title":"BestBuy 自动库存通知","path":"/a23388e86d35/","content":"使用需知本脚本已在Github上开源：https://github.com/RYQ-22/bestbuy-stock-alert ，请注意： 本脚本作为个人使用，功能简陋，但使用简单且可以满足我的需求。若有更复杂的要求，如对其他网站的支持、自动发送邮件等，可以看一下这个项目：https://github.com/Prince25/StockAlertBot （需要自己部署，比本脚本麻烦一些）。 BestBuy默认根据请求IP判断地区，且不同地区的库存状态不同，请在需要查询的地区部署该脚本。 若要部署该脚本为定时任务需要一台不关机的电脑（服务器），相当于Python代替你查看BestBuy网页。 若嫌麻烦不想自己部署，也可以直接订阅网上的库存检测服务（自行Google即可）。 1️⃣ 获得Twilio API1. 打开Twilio官网注册免费账号如图点“Start for free”注册。 注册需要用虚拟手机号，推荐用Google Voice（不要用实体手机号，不然需要运营商验证）。验证完后保存好恢复密钥，然后点击“Continue with trial”。 2. 获得环境变量所需信息 如图进入首页，点击“Get a phone number”，应该会显示如下页面。 点击上方的“Configure”，然后就可以在右边看到我们需要的Service SID。 然后回到主界面，往下滑可以看到“Account Info”。 可以看到我们需要的“Account SID”和“Auth Token”。这里的电话号码不用管，是Twilio用来发短信的号码。 然后从Github的项目界面下载bestbuy.env文件然后编辑，或者直接复制下面的内容然后编辑。注意这里的手机号改为注册时用的Google Voice虚拟手机号。 # bestbuy.envTWILIO_ACCOUNT_SID=YOUR_ACCOUNT_SIDTWILIO_AUTH_TOKEN=YOUR_AUTH_TOKENMESSAGING_SERVICE_SID=YOUR_SERVICE_SIDRECIPIENT_PHONE_NUMBER=+1xxxxxxxxxx 2️⃣ 下载二进制文件经测试，使用非3.9.20版本的Python可能会导致请求时连接超时。为方便使用，可以直接下载Github Release里打包好的二进制文件：https://github.com/RYQ-22/bestbuy-stock-alert/releases/tag/v1.0.0 根据自己的系统下载对应的二进制文件，可能需要允许可执行权限。 3️⃣ 设置为定时任务下载好后，把二进制文件和之前编辑好的bestbuy.env文件放到同一个文件夹。下面介绍如何在不同的系统设置定时任务（实现每隔一段时间检测一次库存状态）。 Linux使用crontab实现：在终端输入 crontab -e 然后把下面的内容插入到文件末尾： */1 7-23 * * * cd your_folder ./bestbuy-stock-alert-1.0.0-linux_x86-64 your_url your_logfile 21 将1改为查询的时间间隔（单位分钟） 将7-23改为该任务的活跃时间（例如只想要在8点到22点之间查询，就改为8-22） 将your_folder改为打包好的二进制文件和bestbuy.env所在的绝对目录 将your_url改为所要查询的Bestbuy商品的网址（默认是https://www.bestbuy.com/site/nvidia-geforce-rtx-5080-16gb-gddr7-graphics-card-gun-metal/6614153.p） 将your_logfile改为日志的文件名 Windows使用schtasks实现，在命令提示符（cmd）或PowerShell中执行以下命令： schtasks /Create /SC MINUTE /MO 1 /TN BestBuy Stock Alert /TR cmd /c \\cd /d \\C:\\\\Path\\\\To\\\\Your\\\\Folder\\ bestbuy-stock-alert-1.0.0-windows-x86-64.exe \\your_url\\ \\C:\\\\Path\\\\To\\\\Your\\\\Log\\\\your_logfile.log\\ 21\\ /ST 07:00 /ET 23:59 将1改为查询的时间间隔（单位分钟） 将07:00和23:59改为该任务每天的开始和结束时间 将C:\\\\Path\\\\To\\\\Your\\\\Folder（注意结尾不包括右斜杠）改为打包好的二进制文件和bestbuy.env所在的绝对目录 将your_url改为所要查询的Bestbuy商品的网址（默认是https://www.bestbuy.com/site/nvidia-geforce-rtx-5080-16gb-gddr7-graphics-card-gun-metal/6614153.p） 将C:\\\\Path\\\\To\\\\Your\\\\Log\\\\your_logfile.log改为日志的绝对路径。若不需要日志，把下面的内容删掉即可： \\C:\\\\Path\\\\To\\\\Your\\\\Log\\\\your_logfile.log\\ 21\\ 设置为任务前可以直接在cmd中试一下看能不能运行： bestbuy-stock-alert-1.0.0-windows-x86-64.exe 4️⃣ 后续部署为定时任务之后，我就把这个放到一边没有管了。没想到，某天早上一起来就看到检测到 PNY 5070Ti OC 有货的短信，再点进链接就卖完了。结果过了十几分钟又补了一次，直接拿下了。含税和返现合rmb 5700块。 原价 5070 Ti OC","tags":["网络"],"categories":["技术"]},{"title":"关于","path":"/about/index.html","content":"突然想写一些中文内容，于是基于 Hexo + Stellar 建立了这个Rickyhub中文站。所谓中文站，即尽量都用中文写，主要包括业余兴趣的技术分享以及一些有感而发的内容。"},{"title":"赞助","path":"/donate/index.html","content":"如果您觉得我的内容对您有帮助，欢迎通过 BTC 或 USDT (ERC20BEP20) 钱包地址支持我的创作。您的每一份支持都是我持续创作的动力！所有赞助将用于网站维护、服务器费用以及内容创作。 bc1q746mq6fk4l8ls0tftce2zr78myr52625m7fm70 BTC 二维码 图片 SHA256 哈希: 7b7ff88e6e699d20be83b2d42924ae72678c90e0ff098079d0d027bf6dd82d33 0xbfDCcb87958f6fd61Ebf474D1E1787f5eBB84bf0 USDT (ERC20BEP20) 二维码 图片 SHA256 哈希: ae8469b4283a93b3d03e46d75163c4e22255b6d7cc1ab7eab2e05aa16cb8b330"},{"title":"友链","path":"/friends/index.html","content":"欢迎添加友链 ^_^ Rickyhub 主站Rickyhub 备用Stellar 作者"}]